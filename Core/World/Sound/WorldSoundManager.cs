using System.Collections.Generic;
using Helion.Audio;
using Helion.Audio.Sounds;
using Helion.Geometry.Vectors;
using Helion.Resources.Archives.Collection;
using Helion.Resources.Definitions.SoundInfo;
using Helion.Util;
using Helion.Util.Extensions;
using Helion.Util.RandomGenerators;
using Helion.World.Entities.Players;

namespace Helion.World.Sound
{
    public class WorldSoundManager : SoundManager, ITickable
    {
        private readonly IWorld m_world;
        
        public WorldSoundManager(IWorld world, IAudioSystem audioSystem, ArchiveCollection archiveCollection) :
            base(audioSystem, archiveCollection)
        {
            m_world = world;
        }
        
        protected override IRandom GetRandom() => m_world.Random;
        
        protected override double GetDistance(ISoundSource soundSource)
        {
            return soundSource.GetDistanceFrom(m_world.ListenerEntity);
        }
        
        public override IAudioSource? PlayStaticSound(string sound)
        {
            ISoundSource soundSource = DefaultSoundSource.Default;
            return m_world.SoundManager.CreateSoundOn(DefaultSoundSource.Default, sound,
                SoundChannelType.Auto, new SoundParams(soundSource));
        }
        
        public IAudioSource? CreateSoundOn(ISoundSource soundSource, string sound, SoundChannelType channel, SoundParams soundParams)
        {
            return CreateSound(soundSource, soundSource.GetSoundPosition(m_world.ListenerEntity), soundSource.GetSoundVelocity(), sound, channel, soundParams);
        }
        
        protected override int GetPriority(ISoundSource soundSource, SoundInfo? soundInfo, SoundParams? soundParams) 
        {
            // Sounds from the listener are top priority.
            // Sounds that do not attenuate are next, then prioritize sounds by the type the entity is producing.
            if (ReferenceEquals(soundSource, m_world.ListenerEntity))
                return 0;
                
            return base.GetPriority(soundSource, soundInfo, soundParams);
        }
        
        protected override SoundInfo? GetSoundInfo(ISoundSource? source, string sound)
        {
            if (source is Player player)
            {
                string playerSound = SoundInfoDefinition.GetPlayerSound(player, sound);
                
                SoundInfo? soundInfo = ArchiveCollection.Definitions.SoundInfo.Lookup(playerSound, m_world.Random);
                if (soundInfo != null)
                    return soundInfo;
            }

            return base.GetSoundInfo(source, sound);
        }
        
        protected override void AttenuateIfNeeded(ISoundSource source, SoundInfo info, SoundParams soundParams)
        {
            // Don't attenuate sounds generated by the listener, otherwise movement can cause the sound to be off
            if (ReferenceEquals(source, m_world.ListenerEntity) || !CanAttenuate(source, info))
                soundParams.Attenuation = Attenuation.None;
        }

        public override void Update()
        {
            Tick();
        }

        public void Tick()
        {
            AudioManager.SetListener(m_world.ListenerPosition, m_world.ListenerAngle, m_world.ListenerPitch);
            UpdateWaitingLoopSounds();
            PlaySounds();

            if (PlayingSounds.Empty())
                return;

            LinkedListNode<IAudioSource>? node = PlayingSounds.First;
            LinkedListNode<IAudioSource>? nextNode;
            while (node != null)
            {
                nextNode = node.Next;
                if (node.Value.IsFinished())
                {
                    node.Value.Dispose();
                    PlayingSounds.Remove(node.Value);
                }
                else
                {
                    double distance = node.Value.AudioData.SoundSource.GetDistanceFrom(m_world.ListenerEntity);
                    if (!CheckDistance(distance, node.Value.AudioData.Attenuation))
                    {
                        node.Value.Stop();
                        PlayingSounds.Remove(node);

                        if (ShouldDisposeBumpedSound(node.Value))
                            node.Value.Dispose();
                    }
                    else
                    {
                        Vec3D? position = node.Value.AudioData.SoundSource.GetSoundPosition(m_world.ListenerEntity);
                        if (position != null)
                            node.Value.SetPosition(position.Value.Float);
                    }
                }

                node = nextNode;
            }
        }
    }
}