namespace Helion.Client.Music;

using OpenTK.Audio.OpenAL;
using System;
using System.Runtime.ExceptionServices;
using System.Threading;
using System.Threading.Tasks;
using ZMusicWrapper;

public class AudioStreamFactory : IOutputStreamFactory
{
    public IOutputStream GetOutputStream(int sampleRate, int channelCount)
    {
        return new AudioStream(sampleRate, channelCount);
    }
}

/// <summary>
/// Provides the functionalities for streaming audio.
/// </summary>
public sealed class AudioStream : IOutputStream
{
    private bool disposed = false;

    /// <summary>
    /// Gets the sample rate of the audio stream.
    /// </summary>
    public int SampleRate { get; private set; }

    /// <summary>
    /// Gets the number of channels of the audio stream.
    /// </summary>
    public int ChannelCount { get; private set; }

    /// <summary>
    /// Gets the latency for audio processing in milliseconds.
    /// </summary>
    public int Latency { get; private set; }

    /// <summary>
    /// Gets the block length for audio processing in sample frames.
    /// </summary>
    public int BlockLength { get; private set; }

    private readonly int[] m_alBuffers;
    private readonly ALFormat m_format;

    private int m_alSource;

    private readonly short[] m_monoBlockData;
    private readonly short[] m_blockData;
    private readonly int[] m_alBufferQueue;
    private readonly int m_bufferRefreshInterval;

    private Func<short[], bool>? m_fillBlock;
    private CancellationTokenSource? m_pollingCts;
    private Task? m_pollingTask;

    /// <summary>
    /// Initializes a new instance of the <see cref="AudioStream"/> class.
    /// </summary>
    /// <param name="sampleRate">The sample rate of the audio stream.</param>
    /// <param name="channelCount">The number of channels of the audio stream. This value must be 1 or 2.</param>
    /// <param name="latency">The desired latency for audio processing in milliseconds.</param>
    /// <param name="blockLength">The desired block length for audio processing in sample frames.</param>
    public AudioStream(int sampleRate, int channelCount, int latency = 200, int blockLength = 2048)
    {
        try
        {
            SampleRate = sampleRate > 0
                ? sampleRate
                : throw new ArgumentException("The sample rate must be a positive value.", nameof(sampleRate));

            ChannelCount = (channelCount == 1 || channelCount == 2)
                ? channelCount
                : throw new ArgumentException("The number of channels must be 1 or 2.", nameof(channelCount));

            Latency = latency > 0
                ? latency
                : throw new ArgumentException("The latency must be a positive value.", nameof(latency));

            BlockLength = blockLength >= 8
                ? blockLength
                : throw new ArgumentException("The block length must be greater than or equal to 8.", nameof(blockLength));

            int bufferCount = Math.Max(4, (int)Math.Ceiling((double)(sampleRate * latency) / (1000 * blockLength)));

            m_alBuffers = new int[bufferCount];
            for (int i = 0; i < m_alBuffers.Length; i++)
            {
                m_alBuffers[i] = AL.GenBuffer();
                if (AL.GetError() != ALError.NoError)
                {
                    throw new Exception("Failed to generate an audio buffer.");
                }
            }

            // Calculate an interval for how often we should wake up and try to fill our buffers.
            // We'll try to wake up when about half of the buffers have been played.
            m_bufferRefreshInterval = bufferCount * blockLength * 1000 / (sampleRate * 2);

            // Work around some other quirks in Helion's audio by _always_ requesting stereo.
            m_format = ALFormat.Stereo16;

            m_alSource = AL.GenSource();
            if (AL.GetError() != ALError.NoError)
            {
                throw new Exception("Failed to generate an audio source.");
            }

            m_monoBlockData = new short[blockLength];
            m_blockData = new short[2 * blockLength];
            m_alBufferQueue = new int[1];
        }
        catch (Exception e)
        {
            Dispose();
            ExceptionDispatchInfo.Throw(e);
        }
    }

    public void SetVolume(float volume)
    {
        AL.Source(m_alSource, ALSourcef.MaxGain, volume);
        AL.Source(m_alSource, ALSourcef.Gain, volume);
    }

    /// <summary>
    /// Plays a sound from the wave data generated by the specified callback function.
    /// </summary>
    /// <param name="fillBlock">The callback function to generate the wave data.  This should return "false" if there is no more data.</param>
    public void Play(Func<short[], bool> fillBlock)
    {
        ObjectDisposedException.ThrowIf(disposed, this);
        ArgumentNullException.ThrowIfNull(fillBlock);

        // If the previous playback is still ongoing, we have to stop it.
        if (m_pollingTask != null)
        {
            m_pollingCts!.Cancel();
            m_pollingTask.Wait();
            m_pollingTask.Dispose();
            m_pollingCts.Dispose();
        }

        // If the source is mono, then just do channel doubling.
        m_fillBlock = ChannelCount == 1
            ? (blockData) => CopyMonoBlock(fillBlock, blockData)
            : fillBlock;

        for (int i = 0; i < m_alBuffers.Length; i++)
        {
            m_fillBlock(m_blockData);
            AL.BufferData(m_alBuffers[i], m_format, m_blockData, SampleRate);
            m_alBufferQueue[0] = m_alBuffers[i];
            AL.SourceQueueBuffers(m_alSource, m_alBufferQueue);
        }

        AL.SourcePlay(m_alSource);

        m_pollingCts = new CancellationTokenSource();
        m_pollingTask = Task.Run(() => PollingLoop(m_pollingCts.Token));
    }

    private bool CopyMonoBlock(Func<short[], bool> fillMonoBlock, short[] blockData)
    {
        // This exists to work around a quirk in OpenAL where it doesn't want to play back mono music
        // if the rest of the environment is in stereo.
        bool result = fillMonoBlock(m_monoBlockData);
        for (int i = 0; i < m_monoBlockData.Length; i++)
        {
            blockData[2 * i] = m_monoBlockData[i];
            blockData[(2 * i) + 1] = m_monoBlockData[i];
        }

        return result;
    }

    /// <summary>
    /// Stops playing sound.
    /// </summary>
    public void Stop()
    {
        ObjectDisposedException.ThrowIf(disposed, this);

        if (m_pollingTask != null)
        {
            m_pollingCts!.Cancel();
            m_pollingTask.Wait();

            m_pollingCts.Dispose();
            m_pollingCts = null;

            m_pollingTask.Dispose();
            m_pollingTask = null;
        }
    }

    private void PollingLoop(CancellationToken ct)
    {
        bool hasData = true;

        while (!ct.IsCancellationRequested && hasData)
        {
            AL.GetSource(m_alSource, ALGetSourcei.BuffersProcessed, out int processedCount);
            for (int i = 0; i < processedCount; i++)
            {
                hasData &= m_fillBlock!(m_blockData);
                AL.SourceUnqueueBuffers(m_alSource, m_alBufferQueue);
                AL.BufferData(m_alBufferQueue[0], m_format, m_blockData, SampleRate);
                AL.SourceQueueBuffers(m_alSource, m_alBufferQueue);
            }

            AL.GetSource(m_alSource, ALGetSourcei.SourceState, out int value);
            if (value == (int)ALSourceState.Stopped)
            {
                AL.SourcePlay(m_alSource);
            }

            Thread.Sleep(m_bufferRefreshInterval);
        }

        AL.SourceStop(m_alSource);

        {
            // We have to unqueue remaining buffers for next playback.
            AL.GetSource(m_alSource, ALGetSourcei.BuffersProcessed, out int processedCount);
            for (int i = 0; i < processedCount; i++)
            {
                AL.SourceUnqueueBuffers(m_alSource, m_alBufferQueue);
            }
        }
    }

    /// <summary>
    /// Gets the current playback state of the channel.
    /// </summary>
    public PlaybackState State
    {
        get
        {
            ObjectDisposedException.ThrowIf(disposed, this);

            AL.GetSource(m_alSource, ALGetSourcei.SourceState, out int sourceState);

            switch ((ALSourceState)sourceState)
            {
                case ALSourceState.Initial:
                case ALSourceState.Stopped:
                    return PlaybackState.Stopped;

                case ALSourceState.Playing:
                    return PlaybackState.Playing;

                case ALSourceState.Paused:
                    return PlaybackState.Paused;

                default:
                    throw new Exception($"Unknown AL source state: {sourceState}");
            }
        }
    }

    /// <summary>
    /// Disposes the resources held by the <see cref="AudioStream"/>.
    /// </summary>
    public void Dispose()
    {
        if (disposed)
        {
            return;
        }

        if (m_pollingTask != null)
        {
            m_pollingCts!.Cancel();
            m_pollingTask.Wait();
            m_pollingTask.Dispose();
            m_pollingTask = null;
            m_pollingCts.Dispose();
            m_pollingCts = null;
        }

        if (m_alSource != 0)
        {
            AL.SourceStop(m_alSource);
            AL.DeleteSource(m_alSource);
            m_alSource = 0;
        }

        if (m_alBuffers != null)
        {
            for (int i = 0; i < m_alBuffers.Length; i++)
            {
                if (m_alBuffers[i] != 0)
                {
                    AL.DeleteBuffer(m_alBuffers[i]);
                    m_alBuffers[i] = 0;
                }
            }
        }

        disposed = true;
        GC.SuppressFinalize(this);
    }
}
